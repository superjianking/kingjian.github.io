<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一段代码破解WiFi</title>
      <link href="/2023/05/24/%E4%B8%80%E6%AE%B5Python%E4%BB%A3%E7%A0%81%E7%A0%B4%E8%A7%A3WiFi/"/>
      <url>/2023/05/24/%E4%B8%80%E6%AE%B5Python%E4%BB%A3%E7%A0%81%E7%A0%B4%E8%A7%A3WiFi/</url>
      
        <content type="html"><![CDATA[<h1 id="昨晚家里停网后，我写了一段代码破解了隔壁小姐姐的-wifi-密码…"><a href="#昨晚家里停网后，我写了一段代码破解了隔壁小姐姐的-wifi-密码…" class="headerlink" title="昨晚家里停网后，我写了一段代码破解了隔壁小姐姐的 wifi 密码…"></a>昨晚家里停网后，我写了一段代码破解了隔壁小姐姐的 wifi 密码…</h1><p>本篇文章转载与公众号<a href="https://mp.weixin.qq.com/s/mET9L3Mt3vJ_gYqEwy3ItA">码农 code 之路</a></p><p>昨晚，家里停网了，对于码农而言，停网了，这能忍？打电话给修网络的，说太晚了，要第二天才能过来…</p><p>突然发现隔壁妹纸的 wifi 信号满格哇，这让我动了邪念，看有没有办法蹭下网，首先，用的是万能钥匙，没有成功~~~</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/icu8ekKAcwiabrhuWLTicjCsU0NbNRUibtPga9oFQW9eblHlnWyjlnYpZkYnPKibLH06LAsIic7ojM9jx2zroHPEOnpw/640?wx_fmt=jpeg&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>那我只能用字典来跑密码了哦，这种小功能，肯定只有交给 python 来完成了，搜了一下发现 pywifi 这个组件刚好满足需求。</p><p>那下面来记录一下我的操作过程。</p><p><strong># 简介</strong></p><p>Python 丰富的第三方库中自然也包括 wifi 的 API，可以很方便的实现 wifi 的连接。如果有一份详细的密码本，可以实现 wifi 密码的暴力破解，前提是你有足够的耐心和时间去等待。</p><p><strong># 思路</strong></p><p>对给定的 wifi 名称，我们循环使用密码去一一做尝试，如果失败就断开连接，直到连接成功为止。</p><p>即导入所需要的第三方库（请自行下载安装好），通过 pywifi 调用网卡接口，依次做测试，循环读取密码尝试连接。在这里只需要修改密码文件路径和 wifi 名称即可。</p><p><strong># 环境准备</strong></p><ul><li>python2.7</li><li>pywifi 模块</li><li>字典</li></ul><p><strong># 导入模块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pywifi import *</span><br></pre></td></tr></table></figure><p><strong># 字典准备</strong></p><p>随机搞的 wifi 弱口令 TOP10。一行只包含一组密码，脚本依次读取每行密码，直到找到正确的密码为止。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/icu8ekKAcwiabrhuWLTicjCsU0NbNRUibtPgZ8R80IBh1iaicIEfMpjDrKlPnmhibRt9olkFOEBnzjqbhj9HhI5l7ncmQ/640?wx_fmt=png&tp=wxpic&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong># 完整代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> ttk</span><br><span class="line"><span class="keyword">import</span> pywifi</span><br><span class="line"><span class="keyword">from</span> pywifi <span class="keyword">import</span> const</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter.filedialog</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MY_GUI</span>():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,init_window_name</span>):</span><br><span class="line">self.init_window_name = init_window_name</span><br><span class="line"></span><br><span class="line"><span class="comment">#密码文件路径</span></span><br><span class="line">self.get_value = StringVar()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取破解wifi账号</span></span><br><span class="line">self.get_wifi_value = StringVar()</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取wifi密码</span></span><br><span class="line">self.get_wifimm_value = StringVar()</span><br><span class="line"></span><br><span class="line">self.wifi = pywifi.PyWiFi()  <span class="comment">#抓取网卡接口</span></span><br><span class="line">self.iface = self.wifi.interfaces()[<span class="number">0</span>] <span class="comment">#抓取第一个无线网卡</span></span><br><span class="line">self.iface.disconnect()  <span class="comment">#测试链接断开所有链接</span></span><br><span class="line">time.sleep(<span class="number">1</span>)  <span class="comment">#休眠1秒</span></span><br><span class="line"><span class="comment">#测试网卡是否属于断开状态</span></span><br><span class="line"><span class="keyword">assert</span> self.iface.status() <span class="keyword">in</span>\</span><br><span class="line">[const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;(WIFI:%s,%s)&#x27;</span> % (self.wifi,self.iface.name())</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置窗口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_init_window</span>(<span class="params">self</span>):</span><br><span class="line">self.init_window_name.title(<span class="string">&quot;WIFI破解工具&quot;</span>)</span><br><span class="line">self.init_window_name.geometry(<span class="string">&#x27;+500+200&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    labelframe = LabelFrame(width=<span class="number">400</span>, height=<span class="number">200</span>,text=<span class="string">&quot;配置&quot;</span>)</span><br><span class="line">    labelframe.grid(column=<span class="number">0</span>, row=<span class="number">0</span>, padx=<span class="number">10</span>, pady=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">self.search = Button(labelframe,text=<span class="string">&quot;搜索附近WiFi&quot;</span>,command=self.scans_wifi_list).grid(column=<span class="number">0</span>,row=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">self.pojie = Button(labelframe,text=<span class="string">&quot;开始破解&quot;</span>,command=self.readPassWord).grid(column=<span class="number">1</span>,row=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">self.label = Label(labelframe,text=<span class="string">&quot;目录路径：&quot;</span>).grid(column=<span class="number">0</span>,row=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">self.path = Entry(labelframe,width=<span class="number">12</span>,textvariable = self.get_value).grid(column=<span class="number">1</span>,row=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">self.file = Button(labelframe,text=<span class="string">&quot;添加密码文件目录&quot;</span>,command=self.add_mm_file).grid(column=<span class="number">2</span>,row=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">self.wifi_text = Label(labelframe,text=<span class="string">&quot;WiFi账号：&quot;</span>).grid(column=<span class="number">0</span>,row=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">self.wifi_input = Entry(labelframe,width=<span class="number">12</span>,textvariable = self.get_wifi_value).grid(column=<span class="number">1</span>,row=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">self.wifi_mm_text = Label(labelframe,text=<span class="string">&quot;WiFi密码：&quot;</span>).grid(column=<span class="number">2</span>,row=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">self.wifi_mm_input = Entry(labelframe,width=<span class="number">10</span>,textvariable = self.get_wifimm_value).grid(column=<span class="number">3</span>,row=<span class="number">2</span>,sticky=W)</span><br><span class="line"></span><br><span class="line">self.wifi_labelframe = LabelFrame(text=<span class="string">&quot;wifi列表&quot;</span>)</span><br><span class="line">self.wifi_labelframe.grid(column=<span class="number">0</span>, row=<span class="number">3</span>,columnspan=<span class="number">4</span>,sticky=NSEW)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义树形结构与滚动条</span></span><br><span class="line">self.wifi_tree = ttk.Treeview(self.wifi_labelframe,show=<span class="string">&quot;headings&quot;</span>,columns=(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>))</span><br><span class="line">self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview)</span><br><span class="line">self.wifi_tree.configure(yscrollcommand=self.vbar.<span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表格的标题</span></span><br><span class="line">self.wifi_tree.column(<span class="string">&quot;a&quot;</span>, width=<span class="number">50</span>, anchor=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">self.wifi_tree.column(<span class="string">&quot;b&quot;</span>, width=<span class="number">100</span>, anchor=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">self.wifi_tree.column(<span class="string">&quot;c&quot;</span>, width=<span class="number">100</span>, anchor=<span class="string">&quot;center&quot;</span>)</span><br><span class="line">self.wifi_tree.column(<span class="string">&quot;d&quot;</span>, width=<span class="number">100</span>, anchor=<span class="string">&quot;center&quot;</span>)</span><br><span class="line"></span><br><span class="line">self.wifi_tree.heading(<span class="string">&quot;a&quot;</span>, text=<span class="string">&quot;WiFiID&quot;</span>)</span><br><span class="line">self.wifi_tree.heading(<span class="string">&quot;b&quot;</span>, text=<span class="string">&quot;SSID&quot;</span>)</span><br><span class="line">self.wifi_tree.heading(<span class="string">&quot;c&quot;</span>, text=<span class="string">&quot;BSSID&quot;</span>)</span><br><span class="line">self.wifi_tree.heading(<span class="string">&quot;d&quot;</span>, text=<span class="string">&quot;signal&quot;</span>)</span><br><span class="line"></span><br><span class="line">self.wifi_tree.grid(row=<span class="number">4</span>,column=<span class="number">0</span>,sticky=NSEW)</span><br><span class="line">self.wifi_tree.bind(<span class="string">&quot;&lt;Double-1&gt;&quot;</span>,self.onDBClick)</span><br><span class="line">self.vbar.grid(row=<span class="number">4</span>,column=<span class="number">1</span>,sticky=NS)</span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索wifi</span></span><br><span class="line"><span class="comment">#cmd /k C:\Python27\python.exe &quot;$(FULL_CURRENT_PATH)&quot; &amp; PAUSE &amp; EXIT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scans_wifi_list</span>(<span class="params">self</span>):  <span class="comment"># 扫描周围wifi列表</span></span><br><span class="line"><span class="comment">#开始扫描</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;^_^ 开始扫描附近wifi...&quot;</span>)</span><br><span class="line">self.iface.scan()</span><br><span class="line">time.sleep(<span class="number">15</span>)</span><br><span class="line"><span class="comment">#在若干秒后获取扫描结果</span></span><br><span class="line">scanres = self.iface.scan_results()</span><br><span class="line"><span class="comment">#统计附近被发现的热点数量</span></span><br><span class="line">nums = <span class="built_in">len</span>(scanres)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数量: %s&quot;</span>%(nums))</span><br><span class="line"><span class="comment">#print (&quot;| %s |  %s |  %s | %s&quot;%(&quot;WIFIID&quot;,&quot;SSID&quot;,&quot;BSSID&quot;,&quot;signal&quot;))</span></span><br><span class="line"><span class="comment"># 实际数据</span></span><br><span class="line">self.show_scans_wifi_list(scanres)</span><br><span class="line"><span class="keyword">return</span> scanres</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示wifi列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_scans_wifi_list</span>(<span class="params">self,scans_res</span>):</span><br><span class="line"><span class="keyword">for</span> index,wifi_info <span class="keyword">in</span> <span class="built_in">enumerate</span>(scans_res):</span><br><span class="line"><span class="comment"># print(&quot;%-*s| %s | %*s |%*s\n&quot;%(20,index,wifi_info.ssid,wifi_info.bssid,,wifi_info.signal))</span></span><br><span class="line">self.wifi_tree.insert(<span class="string">&quot;&quot;</span>,<span class="string">&#x27;end&#x27;</span>,values=(index + <span class="number">1</span>,wifi_info.ssid,wifi_info.bssid,wifi_info.signal))</span><br><span class="line"><span class="comment">#print(&quot;| %s | %s | %s | %s \n&quot;%(index,wifi_info.ssid,wifi_info.bssid,wifi_info.signal))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加密码文件目录</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_mm_file</span>(<span class="params">self</span>):</span><br><span class="line">self.filename = tkinter.filedialog.askopenfilename()</span><br><span class="line">self.get_value.<span class="built_in">set</span>(self.filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Treeview绑定事件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onDBClick</span>(<span class="params">self,event</span>):</span><br><span class="line">self.sels= event.widget.selection()</span><br><span class="line">self.get_wifi_value.<span class="built_in">set</span>(self.wifi_tree.item(self.sels,<span class="string">&quot;values&quot;</span>)[<span class="number">1</span>])</span><br><span class="line"><span class="comment">#print(&quot;you clicked on&quot;,self.wifi_tree.item(self.sels,&quot;values&quot;)[1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取密码字典，进行匹配</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readPassWord</span>(<span class="params">self</span>):</span><br><span class="line">self.getFilePath = self.get_value.get()</span><br><span class="line"><span class="comment">#print(&quot;文件路径：%s\n&quot; %(self.getFilePath))</span></span><br><span class="line">self.get_wifissid = self.get_wifi_value.get()</span><br><span class="line"><span class="comment">#print(&quot;ssid：%s\n&quot; %(self.get_wifissid))</span></span><br><span class="line">self.pwdfilehander=<span class="built_in">open</span>(self.getFilePath,<span class="string">&quot;r&quot;</span>,errors=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">self.pwdStr =self.pwdfilehander.readline()</span><br><span class="line"><span class="comment">#print(&quot;密码: %s &quot; %(self.pwdStr))</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.pwdStr:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">self.bool1=self.connect(self.pwdStr,self.get_wifissid)</span><br><span class="line"><span class="comment">#print(&quot;返回值：%s\n&quot; %(self.bool1) )</span></span><br><span class="line"><span class="keyword">if</span> self.bool1:</span><br><span class="line"><span class="comment"># print(&quot;密码正确：&quot;+pwdStr</span></span><br><span class="line"><span class="comment"># res = &quot;密码:%s 正确 \n&quot;%self.pwdStr;</span></span><br><span class="line">self.res = <span class="string">&quot;===正确===  wifi名:%s  匹配密码：%s &quot;</span>%(self.get_wifissid,self.pwdStr)</span><br><span class="line">self.get_wifimm_value.<span class="built_in">set</span>(self.pwdStr)</span><br><span class="line">tkinter.messagebox.showinfo(<span class="string">&#x27;提示&#x27;</span>, <span class="string">&#x27;破解成功！！！&#x27;</span>)            <span class="built_in">print</span>(self.res)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># print(&quot;密码:&quot;+self.pwdStr+&quot;错误&quot;)</span></span><br><span class="line">self.res = <span class="string">&quot;---错误--- wifi名:%s匹配密码：%s&quot;</span>%(self.get_wifissid,self.pwdStr)            <span class="built_in">print</span>(self.res)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">#对wifi和密码进行匹配</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self,pwd_Str,wifi_ssid</span>):</span><br><span class="line"><span class="comment">#创建wifi链接文件</span></span><br><span class="line">self.profile = pywifi.Profile()</span><br><span class="line">self.profile.ssid =wifi_ssid <span class="comment">#wifi名称</span></span><br><span class="line">self.profile.auth = const.AUTH_ALG_OPEN  <span class="comment">#网卡的开放</span></span><br><span class="line">self.profile.akm.append(const.AKM_TYPE_WPA2PSK)<span class="comment">#wifi加密算法</span></span><br><span class="line">self.profile.cipher = const.CIPHER_TYPE_CCMP    <span class="comment">#加密单元</span></span><br><span class="line">self.profile.key = pwd_Str <span class="comment">#密码</span></span><br><span class="line">self.iface.remove_all_network_profiles() <span class="comment">#删除所有的wifi文件</span></span><br><span class="line">self.tmp_profile = self.iface.add_network_profile(self.profile)<span class="comment">#设定新的链接文件</span></span><br><span class="line">self.iface.connect(self.tmp_profile)<span class="comment">#链接</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> self.iface.status() == const.IFACE_CONNECTED:  <span class="comment">#判断是否连接上</span></span><br><span class="line">isOK=<span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">isOK=<span class="literal">False</span></span><br><span class="line">self.iface.disconnect() <span class="comment">#断开</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#检查断开状态</span></span><br><span class="line"><span class="keyword">assert</span> self.iface.status() <span class="keyword">in</span>\</span><br><span class="line">    [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE]</span><br><span class="line"><span class="keyword">return</span> isOK</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gui_start</span>():</span><br><span class="line">  init_window = Tk()</span><br><span class="line">  ui = MY_GUI(init_window)</span><br><span class="line">  <span class="built_in">print</span>(ui)</span><br><span class="line">  ui.set_init_window()</span><br><span class="line"><span class="comment">#ui.scans_wifi_list()</span></span><br><span class="line"></span><br><span class="line">  init_window.mainloop()</span><br><span class="line"></span><br><span class="line">gui_start()</span><br></pre></td></tr></table></figure><p><strong># 结果</strong></p><p>运行结果如下图所示，你按照图形界面的操作，便能开始跑起来了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/icu8ekKAcwiabrhuWLTicjCsU0NbNRUibtPgj7IZSMNtLoTvD3ro7TuMKjSyhlcWfYIW3FlCwhsmSiaAmX7jHz31ibKw/640?wx_fmt=png&wxfrom=13&tp=wxpic" alt="图片"></p><p>你 get 到了没？</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识WEB前端(HTML表格) 三</title>
      <link href="/2023/05/19/%E5%88%9D%E8%AF%86WEB%E5%89%8D%E7%AB%AF(HTML%E8%A1%A8%E5%8D%95)%20%E4%B8%89/"/>
      <url>/2023/05/19/%E5%88%9D%E8%AF%86WEB%E5%89%8D%E7%AB%AF(HTML%E8%A1%A8%E5%8D%95)%20%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h3 id="表格的语法"><a href="#表格的语法" class="headerlink" title="表格的语法"></a>表格的语法</h3><ul><li><code>table</code>标签：表示表格的开始与结束，表格的所有内容都需要写在这对标签里</li><li><code>tr</code>标签：表示表格的一行</li><li><code>td</code>标签: 表示一个单元格一行中有几个单元格，这一行就有几列，单元格是真正存放数据的地方</li></ul><h3 id="表格的可选标记"><a href="#表格的可选标记" class="headerlink" title="表格的可选标记"></a>表格的可选标记</h3><ul><li><code>caption</code>标签：表格的标题</li><li><code>thead</code>标签：表头部分</li><li><code>tbody</code>标签：表主体部分</li><li><code>th</code>标签：表格中行&#x2F;列的标题，文字加粗显示</li></ul><h3 id="table标签的属性"><a href="#table标签的属性" class="headerlink" title="table标签的属性"></a>table标签的属性</h3><ul><li><code>border = &quot;1px&quot; </code>设置边框</li><li><code>table</code>表格的边框是<strong>带有间距</strong>的，解决方案:给<code>table</code>标签加<code>style=&quot;border-collapse: collapse;&quot;</code>去掉</li></ul><h3 id="不规则的表单"><a href="#不规则的表单" class="headerlink" title="不规则的表单"></a>不规则的表单</h3><p>这是td单元格的属性：</p><ul><li><p><code>colspan=&quot;n&quot; </code>跨列，从当前单元格开始，向右合并n个单元格（n也包含当前单元格）</p></li><li><p><code>rowspan=&quot;n&quot; </code>跨行，从当前单元格开始，向下合n个单元格（n也包含当前单元格）</p><p><strong>注意</strong>：被合并的单元格一定得<code>删掉</code>或<code>注释</code>！</p></li></ul><h3 id="表格的大小"><a href="#表格的大小" class="headerlink" title="表格的大小"></a>表格的大小</h3><ol><li>表格的大小是靠内容撑起来的</li><li>如果修改了某个单元格的<strong>宽度&#x2F;高度</strong>，这个单元格所属的<strong>整列&#x2F;整行</strong>单元格的宽度都会受到影响</li></ol><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>  #有序列表 order list</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  #列表项 list item</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>  #无序列表 unorder list</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> #列表项 list item</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>有序列表的属性<ul><li><code>start=&quot;4&quot; </code>指定列表项编号的起始值</li><li><code>type=&quot;1&quot; </code>指定编号的类型，默认值<strong>1</strong>，代表阿拉伯数字</li><li><code>a</code>小写字母 ，<code>A</code>大写字母， <code>i</code>小写的罗马数字，  <code>I</code>大写的罗马数字</li></ul></li><li>无序列表的属性<ul><li><code>type=&quot;disc&quot;</code>实心圆(默认值)，还有<code>circle</code>空心圆, <code>square</code>方块,<code>none</code>没有标识</li></ul></li></ol><h3 id="列表的嵌套"><a href="#列表的嵌套" class="headerlink" title="列表的嵌套"></a>列表的嵌套</h3><ol><li><code>ul/ol</code>的直接子元素都是<code>li</code>,这是语法规定</li><li>所有被<strong>嵌套</strong>的内容都需要写在<code>li</code>中，这样更符合语义</li><li><code>ul</code>大列表&gt;<code>li</code>大列表下的列表项&gt;<code>ul</code>嵌套在大列表项下的小列表&gt;<code>li</code>小列表的列表项</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h3 id="表单的特点"><a href="#表单的特点" class="headerlink" title="表单的特点"></a>表单的特点</h3><ol><li>H5提供了一些可视化的输入控件</li><li>自动收集整理用户输入的内容，并提交给服务器</li></ol><h3 id="表单的语法和属性"><a href="#表单的语法和属性" class="headerlink" title="表单的语法和属性"></a>表单的语法和属性</h3><p><code>&lt;form&gt;&lt;/form&gt;</code> 表单的开始与结束，表单的所有内容都写在这对标签中</p><p><strong>属性</strong>：<code>action=“#” </code>表示向哪个地址提交收集好的数据</p><p><code>#</code>占位符表示提交到当前页</p><h3 id="input元素"><a href="#input元素" class="headerlink" title="input元素"></a>input元素</h3><ol><li><p>公共属性</p><ol><li><code>type </code>用于设置<code>input</code>元素的类型，默认值是<code>text</code></li><li><code>value </code>用于保存用户输入的值，提交给服务器后，后期可直接获取该属性保存的值，如果控件是按钮，<code>value</code>用于设置按钮上显示的文本</li><li><code>name </code>用于为控件起名，<strong>注意：</strong><code>form</code>表单必须写<code>name</code>否则无法提交本项数据</li></ol></li><li><p>非公共属性</p><ol><li><p>文本框与密码框</p><ul><li><code>type=&quot;text&quot; </code> 普通文本输入框</li><li><code>type=&quot;password&quot; </code>密码框</li></ul><p><strong>属性：</strong></p><p><code>maxlength=5 </code>设置输入的最大长度</p><p><code>placeholder=&quot;&quot; </code>提示文本</p><p><code>value=&quot;&quot; </code>初始值，不写标签中也会默认存在，值是空字符串</p></li><li><p>按钮</p><ul><li><code>type=&quot;submit&quot; </code>提交按钮，自动收集整理用户输入的数据(有name属性的控件)，提交发送请求</li><li><code>type=&quot;reset&quot;</code> 重置按钮，将表单控件初始化，恢复到初始状态，注意不是清空</li><li><code>type=&quot;button&quot; </code>普通按钮，后期需要结合JS代码使用</li></ul><p><strong>注意：</strong>按钮上的<code>value</code>代表的是按钮上的文本</p></li><li><p>单选框与多选框</p><ul><li>type&#x3D;”radio” 单选</li><li>type&#x3D;”checkbox” 多选</li></ul><p><strong>属性：</strong></p><p><code>name</code>(必须加)，为控件起名并用于分组，一组单选框&#x2F;多选框的名称必须相同，才能实现单选效果</p><p><code>value</code>必须写，不然提交的就是<code>on</code></p><p><code>checked</code> 表示当前项被默认选中</p></li><li><p>文件上传</p><ul><li>请输入您要上传的文件<code>&lt;input type=&quot;file&quot; name=&quot;ufile&quot; multiple&gt;</code>,可以设置属性<code>multiple</code>，就可以同时传多个文件了</li></ul></li><li><p>下拉选框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span> <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>提交时，若没有给<code>option</code>添加<code>value</code>属性，提交的值是<code>option</code>之间的文本，若设置了<code>value</code>属性，提交的是<code>value</code>属性的值，<code>multiple</code> 表示下拉选框可以多选，按住<code>Ctrl</code>可以选多个，<code>selected</code> 表示对应的选项默认被选中</li></ul></li><li><p><code>textarea </code>多行文本域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>属性：</strong></p><p><code>cols=&quot;50&quot;</code> 文本域的列数，改变的是宽度</p><p><code>rows=&quot;10&quot; </code>文本域的行数，改变的是高度</p><p><strong>注意：</strong></p><p>默认的文本域大小可以被用户随意拖拽改变，想要禁用拖拽：<code>style = &quot;resize: none;&quot;</code></p></li><li><p><code>label</code>关联控件</p><ul><li>用于进行<code>form</code>表单中<strong>控件与文本之间</strong>的关联，单击文本效果如同单击控件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span>请同意此协议<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>HTML5新增的<code>input</code>控件</p><ol><li><p>数字控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">max</span>=<span class="string">&quot;30&quot;</span> <span class="attr">min</span>=<span class="string">&quot;10&quot;</span> <span class="attr">step</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>min</code>最小值, <code>max</code>最大值,<code>step</code>步长，一次性<strong>递增&#x2F;递减</strong>的大小，默认步长为<strong>1</strong></p><p><em>注意：</em>*</p><p>这个输入框无法阻止用户自行输入数据</p></li></ul></li><li><p>颜色控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>提供了一个取色器，可以选择不同的颜色，默认是黑色</li></ul></li><li><p>日期控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以年月日，后期如果想要其他更加精美的日期效果，可以使用其他的插件</li></ul></li><li><p>月份控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;month&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>选择年-月</li></ul></li><li><p>星期控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;week&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>选择年-周，一年有52周</li></ul></li><li><p>搜索控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在搜索框提供了一个快速删除所有内容的小叉叉</li></ul></li><li><p>范围控件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;10&quot;</span> <span class="attr">max</span>=<span class="string">&quot;30&quot;</span> <span class="attr">step</span>=<span class="string">&quot;7&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>min·最小值</code>，<code>max</code>最大值，<code>step</code>步长，表示数字滑动的跨度</p><p><strong>作用：</strong>可以控制区间，比如音量 地图缩放 进度</p><p><strong>注意：</strong>设置步长时应该选取可以除得尽的值，否则区间中会有一部分值无法被选中</p></li></ul></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题整理</title>
      <link href="/2023/05/18/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/05/18/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h1><h3 id="常用的-npm-x2F-npx-命令有哪些？"><a href="#常用的-npm-x2F-npx-命令有哪些？" class="headerlink" title="常用的 npm&#x2F;npx 命令有哪些？"></a><strong>常用的 npm&#x2F;npx 命令有哪些？</strong></h3><ol><li><code>npm  install </code>包名称 用于安装第三方模块</li><li><code>npm install</code>读取<code>package.json</code>模块说明书文件获取之前下载的模块列表，缺失的会自动下载安装</li><li><code>npm -v</code>查看当前<code>npm</code>的版本</li><li><code>npm init -y</code>生成一个<code>package.json</code>文件，类似于模块说明书</li></ol><h3 id="GET-和-POST-有什么区别"><a href="#GET-和-POST-有什么区别" class="headerlink" title="GET 和 POST 有什么区别"></a><strong>GET 和 POST 有什么区别</strong></h3><ol><li><code> get</code>请求时,获取的传递参数都会显示在<code>url</code>中，会暴露出用户的信息，危险性大</li><li><code>post</code>传参时，用户的信息不会以传参的形式出现在<code>url</code>中，会保存在浏览器<kbd>F12</kbd> 下 的<code>preview</code>里</li></ol><h3 id="varchar-和-char-有什么区别"><a href="#varchar-和-char-有什么区别" class="headerlink" title="varchar 和 char 有什么区别"></a><strong>varchar 和 char 有什么区别</strong></h3><ol><li><code>varchar</code>变长字符串，最大值是 65535，数据操作速度比较慢，通常用于存储变化长度的数据</li><li><code>char</code>定长字符串，最大值是 255， 数据操作速度比较块，通常用于存储固定长度的数据</li></ol><h3 id="AJAX-的请求步骤"><a href="#AJAX-的请求步骤" class="headerlink" title="AJAX 的请求步骤"></a><strong>AJAX 的请求步骤</strong></h3><ol><li>创建<code>http</code>的请求对象</li><li>连接到服务器</li><li>发送请求</li><li>绑定事件，监听服务器</li></ol><h3 id="常用的-css-选择器"><a href="#常用的-css-选择器" class="headerlink" title="常用的 css 选择器"></a><strong>常用的 css 选择器</strong></h3><ol><li><code>+</code>兄弟选择器</li><li><code>*</code>通用选择器</li><li><code>&gt;</code>子代选择器</li><li><code>#</code>id 选择器</li><li><code>.</code>class 选择器</li><li><code>,</code>群组选择器</li><li><code>::</code>伪类选择器</li></ol><h1 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h1><h3 id="Label-的作用是什么，如何使用？"><a href="#Label-的作用是什么，如何使用？" class="headerlink" title="Label 的作用是什么，如何使用？"></a><strong>Label 的作用是什么，如何使用？</strong></h3><ul><li><p><code>Label</code>的作用是关联空件，长用于将文本绑定关联到勾选框，不管是勾选框还是文本，只要没有超过<code>label</code>的范围点击就会获得焦点。</p></li><li><p>使用方法一般是将被绑定的元素设置<code>id</code>，将 id 名填入<code>label</code>的<code>for</code>属性中。</p></li></ul><h3 id="position-的属性有哪些？"><a href="#position-的属性有哪些？" class="headerlink" title="position 的属性有哪些？"></a><strong>position 的属性有哪些？</strong></h3><ul><li><code>flex</code>固定定位,元素参照与<code>html</code>浏览器的大小，元素会脱离文档流</li><li><code>relative</code>相对定位，相对于自身当前位置调整，</li><li><code>absolute</code>绝对定位，配合<code>relative</code>使用，<strong>子绝父相</strong>，如果没有则参照浏览器大小</li></ul><h3 id="数组中常用的-API-有哪些？"><a href="#数组中常用的-API-有哪些？" class="headerlink" title="数组中常用的 API 有哪些？"></a><strong>数组中常用的 API 有哪些？</strong></h3><blockquote><p><code>join()</code>、<code>slice()</code>、<code>reveres()</code>、<code>push()</code>、<code>toString()</code></p></blockquote><h3 id="Date-的构造函数接受哪几种形式的参数？"><a href="#Date-的构造函数接受哪几种形式的参数？" class="headerlink" title="Date 的构造函数接受哪几种形式的参数？"></a><strong>Date 的构造函数接受哪几种形式的参数？</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//获取时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>(x); <span class="comment">//转换时间 x=时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> birthday = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2023-05-11 09:00:00&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> birthday = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2023</span>, <span class="number">05</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> birthday = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2023</span>, <span class="number">05</span>, <span class="number">11</span>, <span class="number">09</span>, <span class="number">00</span>, <span class="number">00</span>);</span><br></pre></td></tr></table></figure><h3 id="git-的提交步骤"><a href="#git-的提交步骤" class="headerlink" title="git 的提交步骤"></a><strong>git 的提交步骤</strong></h3><ol><li>本地初始化仓库<code>git pull</code></li><li>查看当前状态<code>git status</code></li><li>把文件添加到暂存区<code>git add</code></li><li>推送代码到本地仓库<code>git commit -m</code></li><li>提交本地仓库代码到远程仓库<code>git push</code></li></ol><h1 id="第三组"><a href="#第三组" class="headerlink" title="第三组"></a>第三组</h1><h3 id="head-标签有什么作用，其中什么标签必不可少"><a href="#head-标签有什么作用，其中什么标签必不可少" class="headerlink" title="head 标签有什么作用，其中什么标签必不可少?"></a>head 标签有什么作用，其中什么标签必不可少?</h3><blockquote><p>网页的头部，定义了一些配置信息无序列表，<code>meta</code>标签，用于指定页面的字符编码，防止乱码，字符编码不仅有<code>UTF-8</code>，还有<code>gbk</code>国标<br>在<code>head</code>标签中<code>title</code>标签必不可少</p></blockquote><h3 id="伪元素和伪类的区别和作用"><a href="#伪元素和伪类的区别和作用" class="headerlink" title="伪元素和伪类的区别和作用?"></a>伪元素和伪类的区别和作用?</h3><blockquote><p>伪类是用来定义元素特殊状态的，可以用来设置鼠标悬停样式、元素获取焦点样式、设置链接样式等。</p><p>如常见的 <code>hover</code>、<code>activelink</code> 等 2.伪元素也叫伪对象，它不存在文档中，是一个虚拟的元素，可以用来代表某个子元素，但这个子元素并不存在文档中</p></blockquote><h3 id="transition-和-animation-的区别"><a href="#transition-和-animation-的区别" class="headerlink" title="transition 和 animation 的区别"></a>transition 和 animation 的区别</h3><blockquote><p><code>transition</code>是一个过渡的效果，没有中间状态，需要设置触发事件 (如<code>hove</code>r 等) 才能执行;</p><p><code>animation</code>是一个动画的效果，可以在任意一个中间设置状态，不需要设置触发事件就能执行;</p></blockquote><h3 id="pxemrem-的区别及使用场景"><a href="#pxemrem-的区别及使用场景" class="headerlink" title="pxemrem 的区别及使用场景"></a>pxemrem 的区别及使用场景</h3><p><strong>区别 :</strong></p><ul><li><code>px</code> 是屏幕中最小的一个发光点，网页中经常使用</li><li><code>1em:1</code>倍父元素 (赋予的)字体的大小</li><li><code>1rem: 1</code>倍<code>html </code>(浏览器默认) 根元素的字体大小</li></ul><p><strong>使用场景:</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用 <code>px</code> 即可。</li><li>对于需要适配各种移动设备，使用<code>rem</code> ， (如需要适配 <code>iPhone</code> 和 <code>iPad</code> 等分率差别比较挺大的设备)</li></ul><h3 id="如何隐藏一个元素-有几种方式"><a href="#如何隐藏一个元素-有几种方式" class="headerlink" title="如何隐藏一个元素?有几种方式?"></a>如何隐藏一个元素?有几种方式?</h3><ol><li>修改显示模式 <code>display: none</code></li><li>修改元素的不透明度 <code>opacity: 0.3</code></li><li>设置可见度为隐藏 <code>visibility: hidden</code></li><li>利用透明度隐藏 <code>background-color: rgba(0,0,0,0)</code></li></ol><h1 id="第四组"><a href="#第四组" class="headerlink" title="第四组"></a>第四组</h1><h3 id="什么是-margin-重叠问题？如何解决"><a href="#什么是-margin-重叠问题？如何解决" class="headerlink" title="什么是 margin 重叠问题？如何解决?"></a>什么是 margin 重叠问题？如何解决?</h3><ul><li><p>块级元素在垂直方局上相邻的外间距会发生重叠现象，两者取最大值显示，父元素的首尾子元素都有和父元素 重叠的边</p></li><li><p>给父元素加边框，给父元素加内间距，设置 BFC</p></li></ul><h3 id="元素的层叠次序"><a href="#元素的层叠次序" class="headerlink" title="元素的层叠次序"></a>元素的层叠次序</h3><blockquote><p>指多个元素在同一位置重叠时, 哪个元素显示在最上面，可以使用<code>z-index: x</code>属性，<code>x</code>值越大，元素层级越高</p></blockquote><h3 id="其他值到数字值的转换规则"><a href="#其他值到数字值的转换规则" class="headerlink" title="其他值到数字值的转换规则"></a>其他值到数字值的转换规则</h3><ol><li><code>undefied</code> &#x3D; <code>NaN</code></li><li><code>NaN</code> &#x3D; 0</li><li><code>Bollen</code>中,<code>true</code>&#x3D;1,<code>false</code>&#x3D;0</li><li><code>string</code>类型转换时，如含非数字型则转为<code>NaN</code>，空字符转为 0.</li></ol><h3 id="当前文件和目录的绝对路径如何获取"><a href="#当前文件和目录的绝对路径如何获取" class="headerlink" title="当前文件和目录的绝对路径如何获取?"></a>当前文件和目录的绝对路径如何获取?</h3><ol><li><code>__filename</code> 获取当前文件</li><li><code>__dirname</code> 获取当前路径</li></ol><h3 id="git-的提交步骤-1"><a href="#git-的提交步骤-1" class="headerlink" title="git 的提交步骤"></a><strong>git 的提交步骤</strong></h3><ol><li>本地初始化仓库<code>git pull</code></li><li>查看当前状态<code>git status</code></li><li>把文件添加到暂存区<code>git add</code></li><li>推送代码到本地仓库<code>git commit -m</code></li><li>提交本地仓库代码到远程仓库<code>git push</code></li></ol><h1 id="第五组"><a href="#第五组" class="headerlink" title="第五组"></a>第五组</h1><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><ol><li><code>closure</code>代表的是一种状态，本质上是函数运行时产生的作用域对象，但是当前的对象被保存到其他函数的<code>scopes</code>属性里，这时候就称呼其为闭包。</li><li>为什么要存？：如果不存，就会被自动释放，从而导致代码运行失败</li></ol><p><strong>缺点：</strong></p><ol><li>消耗更多内存：原本需要被释放的资源，由于闭包机制被保存下来</li><li>性能比较低</li></ol><h3 id="函数重载说的是什么？"><a href="#函数重载说的是什么？" class="headerlink" title="函数重载说的是什么？"></a>函数重载说的是什么？</h3><blockquote><p>函数重载：同一个函数中，根据实参的个数或类型不同执行不同的逻辑操作</p></blockquote><ol><li>代表可以声明多个同名的函数，其形参个数不同，会被认为是不同的函数</li><li><code>JS</code>不存在这种处理机制，但是函数重载可以有效减少代码。<code>JS</code>中可以通过<code>if</code>判断的方式，实现相同的重载效果<code>&lt;arguments.length&gt;</code></li></ol><h3 id="window-对象是什么？"><a href="#window-对象是什么？" class="headerlink" title="window 对象是什么？"></a>window 对象是什么？</h3><blockquote><p>window 对象：浏览器这个宿主环境中提供的<code>顶级对象</code>，其中存储了所有操作浏览器的<code>API代码</code></p></blockquote><ol><li>直接触发的函数，会自动到顶级对象中查找，所以可以省略<code>window</code>前缀省略</li><li>设定：用<code>var</code>和<code>function</code>在全局作用域中生成的变量默认存储在顶级对象<code>window</code>里</li><li>全局污染：顶级对象理论上是存放系统提供的属性，但是如果把自定义的属性存在顶级对象里，就认为是全局污染<code>&lt;解决：函数作用域/局部作用域&gt;</code></li></ol><h3 id="如何优雅的输出“今天星期几”？"><a href="#如何优雅的输出“今天星期几”？" class="headerlink" title="如何优雅的输出“今天星期几”？"></a>如何优雅的输出“今天星期几”？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;今天星期&#x27;</span>+<span class="string">&#x27;日一二三四五六&#x27;</span>.<span class="title function_">charAt</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="property">get</span> <span class="title class_">Day</span>()));</span><br></pre></td></tr></table></figure><h3 id="当前文件和目录的绝对路径如何获取-1"><a href="#当前文件和目录的绝对路径如何获取-1" class="headerlink" title="当前文件和目录的绝对路径如何获取"></a>当前文件和目录的绝对路径如何获取</h3><ol><li><code>__filename</code> 获取当前文件</li><li><code>__dirname</code> 获取当前路径</li></ol><h1 id="第六组"><a href="#第六组" class="headerlink" title="第六组"></a>第六组</h1><h3 id="如何计算两个时间点的时间差"><a href="#如何计算两个时间点的时间差" class="headerlink" title="如何计算两个时间点的时间差"></a>如何计算两个时间点的时间差</h3><blockquote><p>分别取得两个时间点的时间戳 <code>d.getTima( )</code> ，通过毫秒数和取余的方式来取得天数，小时数，分数，秒数</p></blockquote><h3 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h3><p>箭头函数是匿名函数:</p><ul><li>不能作构造函数，不能用<code>new</code></li><li>不能绑定<code>arquments</code>，要用<code>rest</code>务数解决</li><li>没有原型属性</li><li>不能绑定<code>this</code>，<code>this</code>永远指向其上下文的<code>this</code></li></ul><h3 id="减少页面加载时间角方式"><a href="#减少页面加载时间角方式" class="headerlink" title="减少页面加载时间角方式"></a>减少页面加载时间角方式</h3><blockquote><p>优化图片，优化<code>CSS</code>，减少<code>http</code>请求，网址后加<code>/</code>，多使用精灵图，标明宽度和宽度</p></blockquote><h3 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h3><blockquote><p><code>const</code>和 <code>let</code> ，模板字符串，箭头函数，对象和数组的解构、函数的参数，默认值，<code>for···of</code>、<code>for···in</code>，<code>ES</code>中的类</p></blockquote><h3 id="Node-s-是什么"><a href="#Node-s-是什么" class="headerlink" title="Node:s 是什么?"></a>Node:s 是什么?</h3><blockquote><p>是一个基于 <code>Chrone V8</code>引擎的<code>JavaScript</code>运行时，<code>Node.is</code> 出现之前，<code>JS</code>只能在浏览器运行；出现之后；JS 可以在任何安装 <code>Node.js</code>的环境运行</p></blockquote><h1 id="第七组"><a href="#第七组" class="headerlink" title="第七组"></a>第七组</h1><h3 id="介绍一下-CSS-盒模型"><a href="#介绍一下-CSS-盒模型" class="headerlink" title="介绍一下 CSS 盒模型"></a>介绍一下 CSS 盒模型</h3><ol><li><p><strong>组成：</strong></p><blockquote><p>margin + border + padding + content</p></blockquote></li><li><p><strong>分类：</strong></p><ul><li><p>标准盒模型：<code>width </code>&#x3D; <code>content</code>，设置的 <code>width</code> 只是盒子内容的宽度</p></li><li><p><code>IE</code>盒模型（怪异盒模型）：<code>width</code> &#x3D; <code>content</code> + <code>border </code>+ <code>padding</code></p></li></ul></li></ol><h3 id="创建带有-ID-属性的-DOM-元素有什么副作用？"><a href="#创建带有-ID-属性的-DOM-元素有什么副作用？" class="headerlink" title="创建带有 ID 属性的 DOM 元素有什么副作用？"></a>创建带有 ID 属性的 DOM 元素有什么副作用？</h3><ul><li>会增加内存负担；</li><li>会创建同名的全局变量。</li></ul><h3 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h3><ol><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用 <code>with</code> 语句</li><li>禁止<code> this</code> 指向全局对象</li></ol><h3 id="数组和伪数组的区别？"><a href="#数组和伪数组的区别？" class="headerlink" title="数组和伪数组的区别？"></a>数组和伪数组的区别？</h3><ol><li><strong>共同点:</strong><ul><li>都可以通过索引取值、都有<code>length</code>属性</li></ul></li><li><strong>区别：</strong><ul><li>原型不同：<ul><li>数组原型：<code>Array.prototype</code></li><li>伪数组原型：不一定，是一种集合，不具备数组的方法</li></ul></li></ul></li></ol><h3 id="说一下-SPA-单页面的优缺点？"><a href="#说一下-SPA-单页面的优缺点？" class="headerlink" title="说一下 SPA 单页面的优缺点？"></a>说一下 SPA 单页面的优缺点？</h3><ol><li>优点：<ul><li>体验好，不刷新，减少 请求 数据<code>ajax</code>异步获取 页面流程；</li><li>前后端分离；</li><li>减轻服务端压力；</li><li>共用一套后端程序代码，适配多端。</li></ul></li><li>缺点：<ol><li>首屏加载过慢；</li><li><code>SEO</code>不利于搜索引擎抓取。</li></ol></li></ol><h1 id="第八组"><a href="#第八组" class="headerlink" title="第八组"></a>第八组</h1><h3 id="break、continue、return-的区别？"><a href="#break、continue、return-的区别？" class="headerlink" title="break、continue、return 的区别？"></a>break、continue、return 的区别？</h3><ol><li><code>break</code> 结束当前的循环体(如<code>for···wile</code>)</li><li><code>continue</code>跳出本次循环，继续执行下次循环(如<code>for···wile</code>)</li><li><code>return</code>不仅可以退出循环，还能返回<code>return</code>中值，同时结束当前函数体内代码</li></ol><h3 id="RGBA-和-opacity-的透明效果有什么不同"><a href="#RGBA-和-opacity-的透明效果有什么不同" class="headerlink" title="RGBA 和 opacity 的透明效果有什么不同?"></a>RGBA 和 opacity 的透明效果有什么不同?</h3><blockquote><p><code>opacity</code>会继承父元素的<code>opacity</code>属性，而<code>rgba</code>的元素的后代不会继承不透明属性</p></blockquote><h3 id="画一条-0-5PX-的直线"><a href="#画一条-0-5PX-的直线" class="headerlink" title="画一条 0.5PX 的直线"></a>画一条 0.5PX 的直线</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height: 1px; tranform: scale(0.5)</span><br></pre></td></tr></table></figure><h3 id="和-区别"><a href="#和-区别" class="headerlink" title="==和===区别"></a><code>==</code>和<code>===</code>区别</h3><blockquote><p><code>==</code>当有仅当前两个运算符相等时，它返回<code>true</code>，即不检查数据类型</p><p><code>===</code> 只有在无需类型转换运算数相等情况下，才返回<code>true</code>，需要检数据类型</p></blockquote><h3 id="判断一个值是什么类型有哪些方法？"><a href="#判断一个值是什么类型有哪些方法？" class="headerlink" title="判断一个值是什么类型有哪些方法？"></a>判断一个值是什么类型有哪些方法？</h3><ol><li><code>typeof</code> 运算符</li><li><code>instanceof</code> 运算符</li><li><code>object.prototype.toString</code> 方法</li></ol><h1 id="第九组"><a href="#第九组" class="headerlink" title="第九组"></a>第九组</h1><h3 id="为什么要使用数据库？"><a href="#为什么要使用数据库？" class="headerlink" title="为什么要使用数据库？"></a>为什么要使用数据库？</h3><ol><li>数据保存在内存<ul><li>优点：存取速度快</li><li>缺点：数据不能永久保存</li></ul></li><li>数据保存在文件<ul><li>优点：数据永久保存</li><li>缺点：速度比内存操作慢，查询数据不方便</li></ul></li><li>数据保存在数据库<ul><li>数据永久保存</li><li>使用<code>SQL</code>语句，查询方便效率高</li><li>管理数据方便</li></ul></li></ol><h3 id="说出你知道的-HTTP-常见状态码"><a href="#说出你知道的-HTTP-常见状态码" class="headerlink" title="说出你知道的 HTTP 常见状态码"></a>说出你知道的 HTTP 常见状态码</h3><ol><li><strong>100</strong> <code>Continue</code>表示继续，一般在发送<code>post</code>请求时，已发送了 <code>HTTP header</code>之后，服务器端将返回此信息，表示确认，之后发送具体参数信息。</li><li><strong>200</strong> <code>OK</code>表示正常返回信息。</li><li><strong>202</strong> <code>Accepted</code>表示服务器已接受请求，但尚未处理。</li><li><strong>302</strong> <code>Found</code>表示临时性重定向。</li><li><strong>303</strong> <code>See Other</code>表示临时性重定向，且总是使用<code>GET</code>请求新的<code>URI</code>。</li><li><strong>401</strong> <code>Unauthorized</code>表示请求未授权。</li><li><strong>403</strong> <code>Forbidden</code>表示禁止访问。</li><li><strong>404</strong> <code>Not Found</code>表示找不到如何与<code>URI</code>相匹配的资源。</li><li><strong>500</strong> <code>Internal Server error</code>表示最常见的服务器端错误。</li><li><strong>503</strong> <code>Service Unavailable</code>表示服务器端暂时无法处理请求（可能是过载或维护）。</li></ol><h3 id="什么是三次握手和四次挥手"><a href="#什么是三次握手和四次挥手" class="headerlink" title="什么是三次握手和四次挥手?"></a>什么是三次握手和四次挥手?</h3><ol><li><strong>三次握手：</strong><ul><li>第一次握手是建立连接，客户端发送连接请求报文，并传送规定的数据包；</li><li>第二次握手是服务器端表示接收到连接请求报文，并回传规定的数据包；</li><li>第三次握手是客户端接收到服务器回传的数据包后，给服务器端再次发送数据包。这样就完成了客户端跟服务器的连接和数据传送。</li></ul></li><li><strong>四次挥手</strong>表示当前这次连接请求已经结束，要断开这次连接。<ul><li>第一次挥手是客户端对服务器发起断开请求，</li><li>第二次握手是服务器表示收到这次断开请求，</li><li>第三次握手是服务器表示已经断开连接,</li><li>第四次握手是客户端断开连接。</li></ul></li></ol><h3 id="模块化的-JavaScript-开发的优势是什么？"><a href="#模块化的-JavaScript-开发的优势是什么？" class="headerlink" title="模块化的 JavaScript 开发的优势是什么？"></a>模块化的 JavaScript 开发的优势是什么？</h3><ol><li>优势如下:<ul><li>将功能分离出来，便于更好的维护和开发。</li><li>具有更好的代码组织方式。</li><li>可以按需加载。</li><li>避免了命名冲突。</li><li>解决了依赖管理问题。</li></ul></li></ol><h3 id="为什么要初始化-CSS？"><a href="#为什么要初始化-CSS？" class="headerlink" title="为什么要初始化 CSS？"></a>为什么要初始化 CSS？</h3><blockquote><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没有初始化<code>CSS</code>，往往会导致页面在不同浏览器之间出现差异。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
            <tag> WEB前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识WEB前端(初识HTML) 二</title>
      <link href="/2023/05/18/%E5%88%9D%E8%AF%86WEB%E5%89%8D%E7%AB%AF(%E5%88%9D%E8%AF%86HTML)%20%E4%BA%8C/"/>
      <url>/2023/05/18/%E5%88%9D%E8%AF%86WEB%E5%89%8D%E7%AB%AF(%E5%88%9D%E8%AF%86HTML)%20%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>通过笔记整理<a href="https://baike.baidu.com/item/HTML5/4234903?fr=aladdin">HTML5</a>的介绍，在下文中，我以 VsCode 编辑软件为介绍，讲解操作</p><h1 id="WEB-基础知识"><a href="#WEB-基础知识" class="headerlink" title="WEB 基础知识"></a>WEB 基础知识</h1><h3 id="我们可以做什么？"><a href="#我们可以做什么？" class="headerlink" title="我们可以做什么？"></a>我们可以做什么？</h3><p>​ WEB 前端，也称<strong>大前端技术</strong>，掌握了这门技术，我们可以制作 PC 网页、移动端页面、个人网站、APP、微信公众号、小程序、轻应用、可视化数据· · ·</p><p>​ 可以这么说，所有与界面相关的内容都需要前端，比如：电视界面、智能穿戴设备界面、车机、机器操作系统、无人机控制显示界面· · ·</p><h3 id="我们需要用什么工具？"><a href="#我们需要用什么工具？" class="headerlink" title="我们需要用什么工具？"></a>我们需要用什么工具？</h3><p>用到的工具需要浏览器、代码编辑器；浏览器推荐使用 <strong>Chrome(谷歌)浏览器</strong>，快速、安全是它的优点、所以被程序员所爱；编辑器有 HBuilder、VsCode、Notepad++、IDEA · · ·根据个人习惯和功能使用选择合适、趁手的工具才能打出精铁。</p><h1 id="HTML-入门"><a href="#HTML-入门" class="headerlink" title="HTML 入门"></a>HTML 入门</h1><h3 id="HTML-介绍"><a href="#HTML-介绍" class="headerlink" title="HTML 介绍"></a>HTML 介绍</h3><p>​ HTML，全名：<strong>Hyper Text Markup Language</strong>，翻译成中文叫<strong>超文本标记语言</strong>，它是一门语言，其可以在网页上包含文本、图片、视频、音频、超链接，所以称为<strong>超文本</strong>；HTML 的文件<strong>运行在浏览器上</strong>，它的文件格式以 html 或 htm 为后缀，由浏览器来解析并执行，HTML 代码的运行方式是以<strong>从上到下，从左到右</strong>的顺序<strong>依次运行</strong>,现在学习的是 HTML 第五版本，也叫<strong>HTML5</strong>。</p><h3 id="HTML-语法规则"><a href="#HTML-语法规则" class="headerlink" title="HTML 语法规则"></a>HTML 语法规则</h3><ol><li><p><strong>HTML 完整结构</strong></p><p>我们在 VsCode 上创建一个 HTML 文件，右键新建文件，起名为 day01.html，进入文件后是个空的文件，按住键盘的<kbd>Shift</kbd>+<kbd>1/！</kbd>键,打出感叹号后回车，VsCode 会自动生成补全 HTML 的完整网页结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> #告诉浏览器当前文档是html类型且请用h5的规范来解析代码</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  #表示网页的开始与结束</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    #网页的头部，定义了一些配置信息</span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    #指定页面的字符编码，防止乱码</span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    #网页的标题部分</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  #网页要显示的主体内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>HTML 语法基础</strong></p><p>HTML 语言是由大量标记标签组成，标签可以分成两种，格式为：</p><ul><li><p><strong>双标记标签（封闭类型标签）</strong></p><blockquote><p>&lt;开始标签&gt; 内容区域 &lt;&#x2F;结束标签&gt;</p></blockquote><blockquote><p>例：<code>&lt;h2&gt;Hello World!&lt;/h2&gt;</code></p></blockquote></li><li><p><strong>单标记标签（非封闭类型标签）</strong></p><blockquote><p>&lt;标签名&gt;</p></blockquote><blockquote><p>例：<code>&lt;br&gt;</code></p></blockquote></li></ul></li><li><p><strong>HTML 的注释</strong></p><p>在编写代码中，我们可以使用<strong>注释功能</strong>，这个功能使用后代码<strong>不会被浏览器解析运行</strong>，选中某段代码，利用快捷键<kbd>Ctrl</kbd>+<kbd>/</kbd>，使某段代码不用删除，也不会被执行，再按一次会取消;注释主要用于<strong>增强代码的可读性</strong>和<strong>解释代码</strong>，其格式为：<code>&lt;!--被注释的内容--&gt;</code></p></li></ol><p>​</p><h3 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h3><table><thead><tr><th align="center">标签</th><th align="center">功能</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center"><code>&lt;b&gt;&lt;/b&gt;</code></td><td align="center"><b>测试</b></td><td align="center">加粗</td></tr><tr><td align="center"><code>&lt;i&gt;&lt;/i&gt;</code></td><td align="center"><i>测试</i></td><td align="center">斜体</td></tr><tr><td align="center"><code>&lt;u&gt;&lt;/u&gt;</code></td><td align="center"><u>测试</u></td><td align="center">下划线</td></tr><tr><td align="center"><code>&lt;strong&gt;&lt;/strong&gt;</code></td><td align="center"><strong>测试</strong></td><td align="center">加粗</td></tr><tr><td align="center"><code>&lt;del&gt;&lt;/del&gt;</code></td><td align="center"><del>测试</del></td><td align="center">删除线</td></tr><tr><td align="center"><code>&lt;mark&gt;&lt;/mark&gt;</code></td><td align="center"><mark>测试</mark></td><td align="center">高亮标记</td></tr><tr><td align="center"><code>X&lt;sup&gt;&lt;/sup&gt;</code></td><td align="center">X<sup>2</sup></td><td align="center">上标字</td></tr><tr><td align="center"><code>Y&lt;sub&gt;&lt;/sub&gt;</code></td><td align="center">Y<sub>4</sub></td><td align="center">下标字</td></tr><tr><td align="center"><code>&lt;br&gt;</code></td><td align="center"><br>测试</td><td align="center">换行</td></tr><tr><td align="center"><code>&lt;hr&gt;</code></td><td align="center"><hr></td><td align="center">分割线</td></tr><tr><td align="center"><code>&lt;s&gt;&lt;/s&gt;</code></td><td align="center"><s>测试</s></td><td align="center">删除线</td></tr><tr><td align="center"><code>&amp;copy</code></td><td align="center">©</td><td align="center">版权声明</td></tr><tr><td align="center"><code>&amp;trade</code></td><td align="center">™</td><td align="center">商标符号</td></tr><tr><td align="center"><code>&amp;reg</code></td><td align="center">®</td><td align="center">注册商标</td></tr><tr><td align="center"><code>&amp;divide</code></td><td align="center">÷</td><td align="center">除号</td></tr><tr><td align="center"><code>&amp;lt</code></td><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center"><code>&amp;gt</code></td><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center"><code>&amp;nbsp</code></td><td align="center">测 试</td><td align="center">空格</td></tr><tr><td align="center"><code>lorem</code></td><td align="center">Lorem…</td><td align="center">生成假文</td></tr><tr><td align="center"><code>&lt;p&gt;&lt;/p&gt;</code></td><td align="center"><p>测试</p></td><td align="center">段落标签</td></tr><tr><td align="center"><code>&lt;img src=&quot;图片路径&quot;&gt;</code></td><td align="center"><img width="50px" title="这是引入的图片" src="https://superjianking.com/Myfiles/img/logo.ico"></td><td align="center">图片引入</td></tr><tr><td align="center"><code>&lt;a href=&quot;链接&quot;&gt;&lt;/a&gt;</code></td><td align="center"><a herf="https://www.baidu.com">百度一下</a></td><td align="center">超链接</td></tr></tbody></table><p>以上简单介绍了一些标记标签和转义符号,有些是基于 H5 上添加的标签.标签的写法是不区分大小写的，但是命名的时候需要注意的是我们会用到驼峰命名法，在后面的文章中会详细的介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识WEB前端(基础知识) 一</title>
      <link href="/2023/05/18/%E5%88%9D%E8%AF%86WEB%E5%89%8D%E7%AB%AF(%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)%20%E4%B8%80/"/>
      <url>/2023/05/18/%E5%88%9D%E8%AF%86WEB%E5%89%8D%E7%AB%AF(%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)%20%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>通过笔记整理<a href="https://baike.baidu.com/item/HTML5/4234903?fr=aladdin">HTML5</a>的介绍</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><p>​ 认识 HTML，我们需要先认识它的运行载体，大家都不陌生，<strong>计算机（computer）</strong>，计算机又是由<strong>显示器</strong>，<strong>主机箱</strong>组成，机箱内包含了计算机的核心硬件，有<strong>主板</strong>、<strong>CPU</strong>、<strong>内存条</strong>、<strong>硬盘</strong>、<strong>电源模块</strong>、<strong>网卡</strong>、<strong>光驱</strong>、<strong>散热风扇</strong>、<strong>声卡</strong> · · ·</p><p>​ 这些都称之为硬件，最主要的还是计算机的软件：<strong>系统</strong>，目前主流的系统就是常见的<strong>Windows 系统</strong>和<strong>MacOS</strong>(苹果电脑操作系统)，对于开发的小伙伴来说还有熟悉的<strong>LIinux 系统</strong>，我们可以大概的把电子产品分为两类：<strong>硬件</strong>和<strong>软件</strong>，硬件已经介绍了，而软件在我们的生活中是形影不离的；比如微信、支付宝、美团、高德、淘宝、京东这些主流的生活必备软件，这些软件的制作开发就会用到 CSS、JS、Java 这些强大的开发语言进行美化和开发。详细信息如下：</p><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>​ 这里给大家展示的是一些常用的快捷键方法</p><p><kbd>Ctrl</kbd>+ <kbd>A</kbd> <strong>全选</strong></p><p><kbd>Ctrl</kbd>+ <kbd>C</kbd> <strong>复制</strong></p><p><kbd>Ctrl</kbd>+ <kbd>V</kbd> <strong>粘贴</strong></p><p><kbd>Ctrl</kbd>+ <kbd>X</kbd> <strong>剪切</strong></p><p><kbd>Ctrl</kbd>+ <kbd>Z</kbd> <strong>撤销</strong></p><p><kbd>Ctrl</kbd>+ <kbd>S</kbd> <strong>保存</strong></p><p><kbd>Ctrl</kbd>+ <kbd>E</kbd> <strong>打开资源管理器</strong></p><p><kbd>Tab</kbd>+ <kbd>Alt</kbd> <strong>切换显示窗口</strong></p><h3 id="人机交互"><a href="#人机交互" class="headerlink" title="人机交互"></a>人机交互</h3><p>​ 操作计算机，可以称为人机交互，方式分为两种：</p><ul><li>图形化界面</li><li>命令行方式</li></ul><h1 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h1><p>​ 使用计算机，软件必不可少，而一个软件的生命周期的长短多数由用户的使用数量来决定（个人观点），软件的生命周期指的是软件的产生到报废或停止使用的时间，称为<strong>生命周期</strong>，主要流程如下：</p><ol><li><p><strong>软件定义期</strong></p><ul><li>可行性研究阶段<ul><li>技术、人力、资金、回报率、政策、风俗···</li></ul></li><li>需求分析阶段<ul><li>分为功能性需求与非功能性需</li></ul></li></ul></li><li><p><strong>软件开发期</strong></p><ul><li>概要设计阶段——架构师<ul><li>子系统、模块、技术选型</li></ul></li><li>详细设计阶段——产品经理<ul><li>页面、主体内容、功能… 绘制原型图</li></ul></li><li>编码实现阶段<ul><li>编码相关的所有岗位一起将项目实现出来</li></ul></li><li>测试阶段——测试工程师<ul><li>软件测试</li></ul></li></ul></li><li><p><strong>软件维护期</strong></p><ul><li>部署阶段——运维工程师<ul><li>将软件部署到服务器</li></ul></li><li>维护阶段<ul><li>软件的更新与修复，当一个软件不再维护，说明这个软件生命周期快要结束</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动基础知识</title>
      <link href="/2023/05/13/Linux%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/"/>
      <url>/2023/05/13/Linux%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>以下内容部分摘录自公众号：<code>嵌入式与Linux那些事</code>，仅用于个人交流与学习，如涉及侵权请联系站长删除！</p><h2 id="1-指令"><a href="#1-指令" class="headerlink" title="1.指令"></a>1.指令</h2><h3 id="1-1-常用的-Linux-指令"><a href="#1-1-常用的-Linux-指令" class="headerlink" title="1.1 常用的 Linux 指令"></a>1.1 常用的 Linux 指令</h3><ol><li><p><strong>怎么查看当前进程？怎么执行退出？怎么查看当前路径？</strong><br>查看当前进程： <code>ps</code><br>执行退出： <code>exit</code><br>查看当前路径： <code>pwd</code></p></li><li><p><strong>ls 命令执行什么功能？ 可以带哪些参数？</strong><br><strong>功能</strong><br>列出指定目录中的目录，以及文件<br><strong>参数</strong><br><code>-a</code> 显示所有文件及目录 (. 开头的隐藏文件也会列出)<br><code>-l</code> 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br><code>-r</code> 将文件以相反次序显示(原定依英文字母次序)<br><code>-t</code> 将文件依建立时间之先后次序列出<br><code>-A</code> 同 -a ，但不列出 “.” (目前目录) 及 “…” (父目录)<br><code>-F</code> 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;”<br><code>-R</code> 若目录下有文件，则以下之文件亦皆依序列出</p></li><li><p><strong>创建目录用什么命令？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">mkdir runoob        #在工作目录下，建立一个名为 runoob 的子目录</span><br><span class="line">mkdir -p runoob2/test   #在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。</span><br><span class="line">若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br></pre></td></tr></table></figure></li><li><p><strong>创建文件用什么命令？</strong></p><p><strong>vi 或 vim</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">vi file1.txt #直接创建并打开一个文件file1.txt</span><br></pre></td></tr></table></figure><p><strong>touch</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">touch file2.txt #创建新的空文件file2.txt</span><br></pre></td></tr></table></figure><p><strong>echo</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">echo &quot;this is a new file&quot; &gt; file3.txt   #创建文件file3.txt并将this is a new file写入（说明：使用&gt;指令覆盖文件原内容并重新输入内容，若文件不存在则创建文件。）</span><br><span class="line">echo &quot;add contents&quot; &gt;&gt;file3.txt    #在已存在的文件补充写入新内容add contents（说明：使用&gt;&gt;指令向文件追加内容，原内容将保存。）</span><br></pre></td></tr></table></figure><p><strong>less 、more 、cat</strong></p><p>三者都是将文件内容输出到标准输出，其中 less 和 more 可以分页显示，cat 是显示全部。<br>三者可以根据已经存在的文件创建新的文件。假设已经存在文件 1.txt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cat 1.txt &gt; 2.txt</span><br><span class="line">less 1.txt &gt; 3.txt</span><br><span class="line">more 1.txt &gt; 4.txt</span><br></pre></td></tr></table></figure><p>此时创建的文件内容都和 1.txt 中文件内容相同。</p><p><strong>cd</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cd &gt; file3.txt  #创建新的空文件file3.txt</span><br><span class="line">cd &gt;&gt; file4.txt  #创建新的空文件file4.txt</span><br></pre></td></tr></table></figure><p>cd 最主要的作用是切换目录，在 cd 后面跟&gt;或&gt;&gt;再加上文件名就可以创建一个内容为空的文件。它和 echo 的区别之处在于<strong>echo 可写文件内容，而 cd 并不能</strong>。</p></li><li><p>复制文件用什么命令？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cp –r test/ newtest #将当前目录 test/ 下的所有文件复制到新目录 newtest 下(前-&gt;后)</span><br></pre></td></tr></table></figure></li><li><p>查看文件内容有哪些命令可以使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">vi 文件名  #编辑方式查看，可修改</span><br><span class="line">cat 文件名 #显示全部文件内容</span><br><span class="line">more 文件名 #分页显示文件内容</span><br><span class="line">less 文件名 #与 more 相似，更好的是可以往前翻页</span><br><span class="line">tail 文件名 #仅查看尾部，还可以指定行数</span><br><span class="line">head 文件名 #仅查看头部,还可以指定行数</span><br></pre></td></tr></table></figure></li><li><p>怎么向屏幕输出带空格的字符串，比如”hello world”?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">echo hello world</span><br></pre></td></tr></table></figure></li><li><p>移动文件用哪个命令？改名用哪个命令？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure></li><li><p>删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">rm -rf file/directory    #删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认</span><br><span class="line">rm -rf  directory/       #删除目录 directory，不管该目录下是否有子目录或文件</span><br></pre></td></tr></table></figure></li><li><p>查找文件内容用哪个命令？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">grep test *file  #在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行</span><br><span class="line">grep -r update /etc/acpi #查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串&quot;update&quot;的文件(递归)</span><br><span class="line">grep -v test *test*      #查找文件名中包含 test 的文件中不包含test 的行(排除)</span><br></pre></td></tr></table></figure></li><li><p>查找文件用哪个命令？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">find . -name &quot;*.c&quot;  #将当前目录及其子目录下所有文件后缀为 .c 的文件列出来</span><br><span class="line">find . -ctime -20   #将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span><br></pre></td></tr></table></figure></li><li><p>cat 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cat -n textfile1  #把 textfile1 的文档内容加上行号后输入到屏幕</span><br><span class="line">cat -n textfile1 &gt; textfile2  #把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里</span><br><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3  #把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里</span><br><span class="line">cat /dev/null &gt; /etc/test.txt #清空 /etc/test.txt 文档内容</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-2-常用的-GCC-指令"><a href="#1-2-常用的-GCC-指令" class="headerlink" title="1.2 常用的 GCC 指令"></a>1.2 常用的 GCC 指令</h3><ol><li><p>预处理 (-E .i)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">gcc -E test.c -o test.i #把预处理的结果导出到test.i文件</span><br></pre></td></tr></table></figure></li><li><p>编译为汇编代码(-S .s)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">gcc -S test.i -o test.s #编译器将test.i翻译成汇编语言，并将结果存储在test.s文件中。</span><br></pre></td></tr></table></figure></li><li><p>汇编(-c .o)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">gcc -c test.s -o test.o #将汇编代码编译为目标文件（.o）但不链接</span><br></pre></td></tr></table></figure></li><li><p>链接(无后缀)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">gcc test.o -o test #将生成的目标文件test.o生成最终的可执行文件test</span><br></pre></td></tr></table></figure></li><li><p>一步到位编译(.c 无后缀)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">gcc test.c -o test #将源文件test.c编译链接为可执行文件test</span><br></pre></td></tr></table></figure></li><li><p>多文件编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">gcc test1.c test2.c -o test</span><br></pre></td></tr></table></figure></li><li><p>警告处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">gcc -w test.c -o test  # 忽略编译时的警告</span><br><span class="line">gcc -Wall test.c -o test #编译后显示所有警告</span><br><span class="line">gcc -Werror test.c -o test #在产生警告的地方停止编译</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-常用的-GDB-调试指令"><a href="#1-3-常用的-GDB-调试指令" class="headerlink" title="1.3 常用的 GDB 调试指令"></a>1.3 常用的 GDB 调试指令</h3><ul><li><p>GDB（GNU symbolic debugger）是 GNU Project 调试器</p></li><li><p>GNU 操作系统是一种由自由软件构成的类 Unix 操作系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line"></span><br><span class="line">gcc -g test.c -o test  #编译时生成debug有关的程序信息</span><br><span class="line">gdb test        #启动调试</span><br><span class="line">help #查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</span><br><span class="line">run #重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</span><br><span class="line">start #单步执行，运行程序，停在第一执行语句</span><br><span class="line">list #查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</span><br><span class="line">set #设置变量的值</span><br><span class="line">next #单步调试（逐过程，函数直接执行）,简写n</span><br><span class="line">step #单步调试（逐语句：跳入自定义函数内部执行）,简写s</span><br><span class="line">backtrace #查看函数的调用的栈帧和层级关系,简写bt</span><br><span class="line">frame #切换函数的栈帧,简写f</span><br><span class="line">info #查看函数内部局部变量的数值,简写i</span><br><span class="line">finish #结束当前函数，返回到函数调用点</span><br><span class="line">continue #继续运行,简写c</span><br><span class="line">print #打印值及地址,简写p</span><br><span class="line">quit #退出gdb,简写q</span><br><span class="line">break+num #在第num行设置断点,简写b</span><br><span class="line">info breakpoints #查看当前设置的所有断点</span><br><span class="line">delete breakpoints num #删除第num个断点,简写d</span><br><span class="line">display #追踪查看具体变量值</span><br><span class="line">undisplay #取消追踪观察变量</span><br><span class="line">watch #被设置观察点的变量发生修改时，打印显示</span><br><span class="line">i watch #显示观察点</span><br><span class="line">enable breakpoints #启用断点</span><br><span class="line">disable breakpoints #禁用断点</span><br><span class="line">x #查看内存x/20xw 显示20个单元，16进制，4字节每单元</span><br><span class="line">run argv[1] argv[2] #调试时命令行传参</span><br><span class="line">set follow-fork-mode child #Makefile项目管理：选择跟踪父子进程(fork())</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-4-常用的驱动开发指令"><a href="#1-4-常用的驱动开发指令" class="headerlink" title="1.4 常用的驱动开发指令"></a>1.4 常用的驱动开发指令</h3><ol><li><p>加载&#x2F;卸载驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">insmod/modprobe #加载驱动</span><br><span class="line">rmmod   #卸载驱动Linux驱动如何查看驱动模块中打印信息？</span><br></pre></td></tr></table></figure></li><li><p>Linux 驱动如何查看驱动模块中打印信息？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">dmesg</span><br></pre></td></tr></table></figure></li><li><p>如何查看内核中已有的字符设备的信息？</p><p><code>lsmod</code> 和<code>modprobe</code>：<code>lsmod</code>可以查看模块的依赖关系，<code>modprobe</code>在加载模块时会加载其他依赖的模块。</p></li><li><p>如何查看正在使用的有哪些中断号？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cat /proc/interrupt</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-Uboot"><a href="#2-Uboot" class="headerlink" title="2.Uboot"></a>2.Uboot</h2><h3 id="2-1-什么是-bootloader？"><a href="#2-1-什么是-bootloader？" class="headerlink" title="2.1 什么是 bootloader？"></a>2.1 什么是 bootloader？</h3><ul><li>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段 bootloader 程序。这段 bootloader 程序会先<strong>初始化时钟，看门狗，中断，SDRAM，等外设，然后将 Linux 内核从 flash（NAND, NOR FLASH,SD,MMC 等）拷贝到 SDRAM 中，最后启动 Linux 内核</strong>。当然了， bootloader 的实际工作要复杂的多，但是它最主要的工作就是启动 Linux 内核。</li><li>bootloader 和 Linux 内核的关系就跟 PC 上的 BIOS 和 Windows 的关系一样，<strong>bootloader 就相当于 BIOS。总得来说，Bootloader 就是一小段程序，它在系统上电时开始执行，初始化硬件设各、准备好软件环境，最后调用操作系统内核</strong>。</li></ul><h3 id="2-2-uboot-启动过程中做了那些事？"><a href="#2-2-uboot-启动过程中做了那些事？" class="headerlink" title="2.2 uboot 启动过程中做了那些事？"></a>2.2 uboot 启动过程中做了那些事？</h3><ol><li><p><strong>第一阶段</strong><br>初始化时钟，关闭看门狗，关中断，启动 ICACHE，关闭 DCACHE 和 TLB，关闭 MMU，初始化 SDRAM，初始化 NAND FLASH，重定位。</p><blockquote><p>Linux 的看门狗（Watchdog）是一种硬件或软件机制，用于监视系统的运行状态，以防止系统出现故障或死机的情况。它能够检测到系统的异常情况并自动采取一些预设的措施，例如重启系统或发送警报信息。</p></blockquote></li><li><p><strong>第二阶段</strong><br>初始化一个串口，检测系统内存映射，将<strong>内核映象和根文件系统映象从 Flash 上读到 SDRAM 空间</strong>中，为内核设置启动参数，调用内核。</p></li></ol><h3 id="2-3-uboot-和内核如何完成参数传递？"><a href="#2-3-uboot-和内核如何完成参数传递？" class="headerlink" title="2.3 uboot 和内核如何完成参数传递？"></a>2.3 uboot 和内核如何完成参数传递？</h3><ul><li>uboot 启动后已经完成了基本的硬件初始化（如：内存、串口等），接下来，它的主要任务就是加载 Linux 内核到开发板的内存，然后跳转到 Linux 内核所在的地址运行。<br><strong>PS:只要问到 uboot，面试官必问 uboot 和内核的参数传递，所以一定要知道！</strong><br>具体是如何跳转呢？做法很简单，直接修改 PC 寄存器的值为 Linux 内核所在的地址，这样 CPU 就会从 Linux 内核所在的地址去取指令，从而执行内核代码。</li><li>在前面我们已经知道，在跳转到内核以前，uboot 需要做好以下三件事情：<ol><li><strong>CPU 寄存器的设置</strong><br>R0&#x3D;0<br>R1&#x3D;机器类型 ID；对于 ARM 结构的 CPU，其机器类型 ID 可以参见 linux&#x2F;arch&#x2F;arm tools&#x2F; mach-types<br>R2&#x3D;启动参数标记列表在 RAM 中起始基地址</li><li><strong>CPU 工作模式</strong><br>必须禁止中断（IRQs 和 FIQs）<br>CPU 必须为 SVC 模式</li><li><strong>Cache 和 MMU 的设置</strong><br>MMU 必须关闭<br>指令 Cache 可以打开也可以关闭<br>数据 Cache 必须关闭<br>其中上面第一步 CPU 寄存器的设置中，就是通过 R0，R1，R2 三个参数给内核传递参数的。</li></ol></li></ul><h3 id="2-4-为什么要给内核传递参数呢？"><a href="#2-4-为什么要给内核传递参数呢？" class="headerlink" title="2.4 为什么要给内核传递参数呢？"></a>2.4 为什么要给内核传递参数呢？</h3><ul><li>在此之前，uboot 已经完成了硬件的初始化，可以说已经”适应了“这块开发板。然而，内核并不是对于所有的开发板都能完美适配的（如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以完美的适配各种开发板），此时，对于开发板的环境一无所知。所以，要想启动 Linux 内核，uboot 必须要给内核传递一些必要的信息来告诉内核<strong>当前所处的环境</strong>。</li></ul><h3 id="2-5-如何给内核传递参数？"><a href="#2-5-如何给内核传递参数？" class="headerlink" title="2.5 如何给内核传递参数？"></a>2.5 如何给内核传递参数？</h3><ul><li>uboot 把<strong>机器 ID 通过 R1 传递给内核</strong>，Linux 内核运行的时候，首先就从 R1 中读取机器 ID 来判断是否支持当前机器。这个机器 ID 实际上就是开发板<strong>CPU 的 ID</strong>，每个厂家生产出一款 CPU 的时候都会给它指定一个唯一的 ID，大家可以到 uboot 源码的<code>arch\arm\include\asm\mach-type.h</code>文件中去查看。</li></ul><p><a href="https://tuchuang.voooe.cn/images/2023/03/19/_ddc0a2e996fc49f9.png"><img src="https://tuchuang.voooe.cn/images/2023/03/19/_ddc0a2e996fc49f9.png" alt="img"></a></p><ul><li><strong>R2 存放的是块内存的基地址</strong>，这块内存中存放的是 uboot 给 Linux 内核的其他参数。这些参数有内存的<strong>起始地址、内存大小、Linux 内核启动后挂载文件系统的方式</strong>等信息。很明显，参数有多个，不同的参数有不同的内容，为了让 Linux 内核能精确的解析出这些参数，双方在传递参数的时候要求参数在存放的时猴需要按照<strong>双方规定的格式存放</strong>。</li><li>除了约定好参数存放的地址外，还要<strong>规定参数的结构</strong>。Linux2.4.x 以后的内核都期望以<strong>标记列表</strong>（tagged_list）的形式来传递启动参数。标记，就是一种数据结构；标记列表，就是挨着存放的多个标记。标记列表以标记<code>ATAG_CORE</code>开始，以标记<code>ATAG_NONE</code>结束。</li><li>标记的数据结构为 tag，它<strong>由一个 tag_header 结构和一个联合（union）组成</strong>。tag<em>header 结构表示标记的类型及长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合（union），比如表示内存时使用 tag</em> mem32，表示命令行时使用 tag_cmdline。具体代码见<code>arch\arm\include\asm\setup.h</code>。</li></ul><p><a href="https://tuchuang.voooe.cn/images/2023/03/19/_8bc5f63ffa1c78c9.png"><img src="https://tuchuang.voooe.cn/images/2023/03/19/_8bc5f63ffa1c78c9.png" alt="img"></a></p><ul><li>从上面可以看出，struct_tag 结构体由 structtag_header+联合体 union 构成，结构体 struct tag_header 用来描述每个 tag 的头部信息，如 tag 的类型，tag 大小。联合体 union 用来描述每个传递给 Linux 内核的参数信息。</li></ul><h3 id="2-5-为什么-uboot-要关掉-caches？"><a href="#2-5-为什么-uboot-要关掉-caches？" class="headerlink" title="2.5 为什么 uboot 要关掉 caches？"></a>2.5 为什么 uboot 要关掉 caches？</h3><ul><li>caches 是 cpu 内部的一个 2 级缓存，它的作用是将常用的数据和指令放在 cpu 内部。caches 是通过 CP15 管理的，刚上电的时候，cpu 还不能管理 caches。上电的时候指令 cache 可关闭，也可不关闭，但<strong>数据 cache 一定要关闭</strong>，否则可能导致刚开始的代码里面，去取数据的时候，从 cache 里面取，而这时候<strong>RAM 中数据还没有 caches 过来，导致数据预取异常</strong>。</li></ul><h2 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h2><h3 id="3-1-什么是根文件系统？"><a href="#3-1-什么是根文件系统？" class="headerlink" title="3.1 什么是根文件系统？"></a>3.1 什么是根文件系统？</h3><ul><li>根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，但是相对于普通的文件系统，它的特殊之处在于，它是<strong>内核启动时所挂载（mount）的第一个文件系统</strong>，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些<strong>初始化脚本（如 rcS、inittab）和服务</strong>加载到内存中去运行，里面包含了 Linux 系统能够运行<strong>所必需的应用程序、库</strong>等，比如可以给用户提供操作 Linux 的控制界面的 shell 程序、动态连接的程序运行时需要的 glibc 库等。</li><li>文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办法真正的启动 Linux 操作系统的，会出现无法加载文件系统的错误。</li></ul><h3 id="3-2-根文件系统为什么这么重要？"><a href="#3-2-根文件系统为什么这么重要？" class="headerlink" title="3.2 根文件系统为什么这么重要？"></a>3.2 根文件系统为什么这么重要？</h3><ul><li>根文件系统之所以在前面加一个“根”，说明它是加载其它文件系统的“根”，那么<strong>如果没有这个根，其它的文件系统也就没有办法进行加载的</strong>。根文件系统包含系统启动时<strong>所必须的目录和关键性的文件</strong>，以及使其他文件系统得以挂载（mount）所必要的文件。例如：<ul><li>init 进程的应用程序必须运行在根文件系统上。</li><li>根文件系统提供了根目录“&#x2F;”。</li><li>linux 挂载分区时所依赖的信息存放于根文件系统<code>/etc/fstab</code>这个文件中。</li><li>shell 命令程序必须运行在根文件系统上，譬如<code>ls</code>、<code>cd</code>等命令。</li></ul></li><li>总结：一套 linux 体系，只有内核本身是不能工作的，必须要 rootfs（上的 etc 目录下的配置文件、<code>/bin/sbin</code>等目录下的 shell 命令，还有&#x2F;lib 目录下的库文件等）相配合才能工作。</li></ul><h3 id="3-3-可执行映像文件通常由几部分构成，它们有什么特点？"><a href="#3-3-可执行映像文件通常由几部分构成，它们有什么特点？" class="headerlink" title="3.3 可执行映像文件通常由几部分构成，它们有什么特点？"></a>3.3 可执行映像文件通常由几部分构成，它们有什么特点？</h3><p>可执行映像文件通常由以下几部分构成：</p><ul><li>一个或多个代码段，代码段的属性为只读。</li><li>零个或多个包含初始化数据的数据段，数据段的属性为可读写。</li><li>零个或多个不包含初始化数据的数据段，数据段的属性为可读写。</li></ul><h2 id="4-中断"><a href="#4-中断" class="headerlink" title="4.中断"></a>4.中断</h2><h3 id="4-1-硬中断-x2F-软中断是什么？有什么区别？"><a href="#4-1-硬中断-x2F-软中断是什么？有什么区别？" class="headerlink" title="4.1 硬中断 &#x2F; 软中断是什么？有什么区别？"></a>4.1 硬中断 &#x2F; 软中断是什么？有什么区别？</h3><ul><li><p><strong>硬中断</strong></p><ol><li>硬中断是由<strong>硬件</strong>产生的，比如，像磁盘，网卡，键盘，时钟等。<strong>每个设备或设备集都有它自己的 IRQ</strong>（中断请求）。基于 IRQ，CPU 可以将相应的请求分发到对应的硬件驱动上（注：硬件驱动通常是内核中的一个子程序，而不是一个独立的进程）。</li><li>处理中断的驱动是需要运行在 CPU 上的，因此，当中断产生的时候，CPU 会中断当前正在运行的任务，来处理中断。在有多核心的系统上，<strong>一个中断通常只能中断一颗 CPU</strong>（也有一种特殊的情况，就是在大型主机上是有硬件通道的，它可以在没有主 CPU 的支持下，可以同时处理多个中断。）。</li><li><strong>硬中断可以直接中断 CPU</strong>。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程，中断代码本身也可以被其他的硬中断中断。</li><li>对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在是为了让<strong>调度代码（或称为调度器）可以调度多任务</strong>。</li></ol></li><li><p><strong>软中断</strong></p><ol><li>软中断的处理非常像硬中断。然而，它们仅仅是由<strong>当前正在运行的进程</strong>所产生的。</li><li><strong>通常，软中断是一些对 I&#x2F;O 的请求</strong>。这些请求会调用内核中可以调度 I&#x2F;O 发生的程序。<strong>对于某些设备，I&#x2F;O 请求需要被立即处理，而磁盘 I&#x2F;O 请求通常可以排队并且可以稍后处理</strong>。根据 I&#x2F;O 模型的不同，进程或许会被挂起直到 I&#x2F;O 完成，此时内核调度器就会选择另一个进程去运行。I&#x2F;O 可以在进程之间产生。并且调度过程通常和磁盘 I&#x2F;O 的方式是相同。</li><li><strong>软中断仅与内核相联系</strong>。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行。</li><li>软中断并不会直接中断 CPU。也<strong>只有当前正在运行的代码（或进程）才会产生软中断</strong>。这种中断是一种<strong>需要内核为正在运行的进程去做一些事情</strong>（通常为 I&#x2F;O）的请求。有一个特殊的软中断是 Yield 调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行。</li></ol><blockquote><p>说人话就是只会影响内核去间接调度 CPU，而不会直接中断 CPU 去处理中断服务程序</p></blockquote></li><li><p>区别</p><ol><li>软中断是执行<strong>中断指令</strong>产生的，而硬中断是由<strong>外设</strong>引发的。</li><li>硬中断的中断号是由<strong>中断控制器</strong>提供的，软中断的中断号由指令直接指出，无需使用中断控制器。</li><li>硬中断是<strong>可屏蔽</strong>的，软中断不可屏蔽。</li><li>硬中断处理程序要确保它能<strong>快速</strong>地完成任务，这样程序执行时才不会等待较长时间，称为<strong>上半部</strong>。</li><li>软中断处理<strong>硬中断未完成的工作</strong>，是一种推后执行的机制，属于<strong>下半部</strong>。</li></ol></li></ul><h3 id="4-2-中断为什么要区分上半部和下半部？"><a href="#4-2-中断为什么要区分上半部和下半部？" class="headerlink" title="4.2 中断为什么要区分上半部和下半部？"></a>4.2 中断为什么要区分上半部和下半部？</h3><ul><li>Linux 中断分为硬件中断和内部中断（异常），调用过程：<strong>外部中断产生-&gt;发送中断信号到中断控制器-&gt;通知处理器产生中断的中断号</strong>，让其进一步处理。</li><li>对于中断上半部和下半部的产生，为了中断处理过程中被新的中断打断，将中断处理一分为二，<strong>上半部登记新的中断，快速处理简单的任务，剩余复杂耗时的处理留给下半部处理，下半部处理过程中可以被中断，上半部处理时不可被中</strong>断。</li></ul><h3 id="4-3-中断下半部一般如何实现？"><a href="#4-3-中断下半部一般如何实现？" class="headerlink" title="4.3 中断下半部一般如何实现？"></a>4.3 中断下半部一般如何实现？</h3><ul><li><strong>软中断、tasklet、工作队列</strong></li><li><a href="https://blog.csdn.net/qq_16933601/article/details/107239908?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161962026516780264032212%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161962026516780264032212&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-107239908.pc_v2_rank_blog_default&utm_term=%E4%B8%AD%E6%96%AD%E9%A1%B6%E5%8D%8A%E9%83%A8%E5%92%8C%E5%BA%95%E5%8D%8A%E9%83%A8%E7%9A%84%E7%90%86%E8%A7%A3">详细版解释</a></li></ul><h3 id="4-4-linux-中断的响应执行流程？中断的申请及何时执行-何时执行中断处理函数-？"><a href="#4-4-linux-中断的响应执行流程？中断的申请及何时执行-何时执行中断处理函数-？" class="headerlink" title="4.4 linux 中断的响应执行流程？中断的申请及何时执行(何时执行中断处理函数)？"></a>4.4 linux 中断的响应执行流程？中断的申请及何时执行(何时执行中断处理函数)？</h3><ul><li>中断的响应流程：<strong>cpu 接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半部-&gt;恢复中断上下文</strong>。</li><li>中断的申请 request_irq 的正确位置：应该是在第一次打开、硬件被告知中断之前。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
